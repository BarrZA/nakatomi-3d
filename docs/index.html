<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Nakatomi Plaza 1988 — Three.js (no external controls)</title>
<style>
  html, body { margin:0; height:100%; background:#000; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
  #app { position:fixed; inset:0; }
  .ui { position:fixed; top:12px; right:12px; background:rgba(255,255,255,.9); padding:8px 10px; border-radius:12px; font-size:12px; font-weight:600; }
  .hint { position:fixed; bottom:12px; left:50%; transform:translateX(-50%); color:#fff; font-size:12px; background:rgba(0,0,0,.45); padding:6px 10px; border-radius:999px; }
</style>
</head>
<body>
<div id="app"></div>
<div class="ui">Day <input id="toggle" type="checkbox" checked /> Night</div>
<div class="hint">Drag to orbit • Scroll to zoom</div>

<!-- Only dependency: Three.js (OrbitControls removed) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
(function(){
  // Minimal orbit controls (no external file)
  class SimpleOrbit {
    constructor(camera, dom, opts={}){
      this.camera = camera;
      this.dom = dom;
      this.target = new THREE.Vector3(0, 10, 0);
      this.minDist = opts.minDist ?? 18;
      this.maxDist = opts.maxDist ?? 90;
      // start from current camera position
      const off = camera.position.clone().sub(this.target);
      this.radius = off.length();
      this.theta = Math.atan2(off.x, off.z);
      const yclamp = Math.min(Math.max(off.y/this.radius, -0.999), 0.999);
      this.phi = Math.acos(yclamp); // 0..PI
      this._drag = false;
      this._px = 0; this._py = 0;
      dom.addEventListener('mousedown', e=>{ this._drag=true; this._px=e.clientX; this._py=e.clientY; });
      window.addEventListener('mouseup', ()=>{ this._drag=false; });
      window.addEventListener('mousemove', e=>{
        if(!this._drag) return;
        const dx = e.clientX - this._px, dy = e.clientY - this._py;
        this._px = e.clientX; this._py = e.clientY;
        this.theta -= dx * 0.005;
        this.phi   += dy * 0.005;
        this.phi = Math.max(0.05, Math.min(Math.PI - 0.05, this.phi));
      });
      dom.addEventListener('wheel', e=>{
        e.preventDefault();
        const s = Math.exp((e.deltaY>0?1:-1) * 0.1);
        this.radius = Math.max(this.minDist, Math.min(this.maxDist, this.radius * s));
      }, { passive:false });
      // touch
      let t0=null;
      dom.addEventListener('touchstart', e=>{ if(e.touches.length===1){ t0={x:e.touches[0].clientX, y:e.touches[0].clientY}; } });
      dom.addEventListener('touchmove', e=>{
        if(e.touches.length===1 && t0){
          const dx = e.touches[0].clientX - t0.x, dy = e.touches[0].clientY - t0.y;
          t0 = {x:e.touches[0].clientX, y:e.touches[0].clientY};
          this.theta -= dx * 0.005;
          this.phi   += dy * 0.005;
          this.phi = Math.max(0.05, Math.min(Math.PI - 0.05, this.phi));
        }
        if(e.touches.length===2){
          const [a,b]=e.touches;
          const dist = Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
          if(this._lastPinch!=null){
            const s = this._lastPinch/dist;
            this.radius = Math.max(this.minDist, Math.min(this.maxDist, this.radius * s));
          }
          this._lastPinch = dist;
        }
      }, {passive:false});
      dom.addEventListener('touchend', ()=>{ t0=null; this._lastPinch=null; });
    }
    update(){
      // spherical to cartesian
      const sinp = Math.sin(this.phi);
      const x = this.target.x + this.radius * sinp * Math.sin(this.theta);
      const y = this.target.y + this.radius * Math.cos(this.phi);
      const z = this.target.z + this.radius * sinp * Math.cos(this.theta);
      this.camera.position.set(x,y,z);
      this.camera.lookAt(this.target);
    }
  }

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.getElementById('app').appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  const nightColor = new THREE.Color('#0d1117');
  const dayColor = new THREE.Color('#cfe3ff');
  scene.background = nightColor;
  scene.fog = new THREE.Fog(scene.background, 60, 160);

  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 500);
  camera.position.set(26,24,30);

  const controls = new SimpleOrbit(camera, renderer.domElement, { minDist:18, maxDist:90 });

  const ambient = new THREE.AmbientLight(0xffffff, 0.35);
  scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 1.25);
  dir.position.set(-20,30,15);
  dir.castShadow = true;
  dir.shadow.mapSize.set(2048,2048);
  scene.add(dir);

  const ground = new THREE.Mesh(new THREE.PlaneGeometry(120,120), new THREE.MeshStandardMaterial({ color:'#dadfe6' }));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

  const tiles = new THREE.Group();
  for(let i=0;i<24;i++){
    const x = (i%6-2.5)*7; const z = (Math.floor(i/6)-2.5)*7;
    const tile = new THREE.Mesh(new THREE.PlaneGeometry(6.5,6.5), new THREE.MeshStandardMaterial({ color:(i%2===0)?'#e9edf3':'#f2f5f9' }));
    tile.rotation.x = -Math.PI/2; tile.position.set(x,0.01,z); tile.receiveShadow = true; tiles.add(tile);
  }
  scene.add(tiles);

  const building = new THREE.Group(); scene.add(building);
  const podium = new THREE.Mesh(new THREE.BoxGeometry(18,2,18), new THREE.MeshStandardMaterial({ color:'#3a3f45', roughness:0.7, metalness:0.1 }));
  podium.position.y = 1; podium.castShadow = podium.receiveShadow = true; building.add(podium);
  const canopy = new THREE.Mesh(new THREE.BoxGeometry(8,0.5,2), new THREE.MeshStandardMaterial({ color:'#2b2f34' }));
  canopy.position.set(0, 2+0.25, 7.8); canopy.castShadow = canopy.receiveShadow = true; building.add(canopy);
  const limoBody = new THREE.Mesh(new THREE.BoxGeometry(3.6,0.6,1.2), new THREE.MeshStandardMaterial({ color:'#111' }));
  limoBody.position.set(3.5, 0.6, 6.5); limoBody.castShadow = limoBody.receiveShadow = true; building.add(limoBody);
  const limoTop = new THREE.Mesh(new THREE.BoxGeometry(3.2,0.2,1.1), new THREE.MeshStandardMaterial({ color:'#0c0c0c' }));
  limoTop.position.set(3.5, 0.95, 6.5); building.add(limoTop);
  function wheel(x,z){ const w=new THREE.Mesh(new THREE.CylinderGeometry(0.22,0.22,0.4,16), new THREE.MeshStandardMaterial({ color:'#222' })); w.rotation.z=Math.PI/2; w.position.set(3.5+x,0.8,6.5+z); return w; }
  building.add(wheel(-1.4,-0.45),wheel(-1.4,0.45),wheel(1.4,-0.45),wheel(1.4,0.45));

  const tower = new THREE.Mesh(new THREE.BoxGeometry(12,28,12), new THREE.MeshStandardMaterial({ color:'#4a4f57', roughness:0.6, metalness:0.2 }));
  tower.position.y = 2 + 28/2; tower.castShadow = tower.receiveShadow = true; building.add(tower);
  const stripeMat = new THREE.MeshStandardMaterial({ color:'#9fb4c7', metalness:0.6, roughness:0.25 });
  for(let i=0;i<14;i++){ const stripe = new THREE.Mesh(new THREE.BoxGeometry(11.9,0.18,11.9), stripeMat); stripe.position.set(0, 2+1+i*2, 0); stripe.receiveShadow = true; building.add(stripe); }
  const mid = new THREE.Mesh(new THREE.BoxGeometry(10,6,10), new THREE.MeshStandardMaterial({ color:'#434853' }));
  mid.position.y = 2 + 28 + 6/2 - 1; mid.castShadow = mid.receiveShadow = true; building.add(mid);
  for(let i=0;i<3;i++){ const mstripe = new THREE.Mesh(new THREE.BoxGeometry(9.9,0.15,9.9), stripeMat); mstripe.position.y = 2 + 28 + i*1.5; building.add(mstripe); }
  const crown = new THREE.Mesh(new THREE.BoxGeometry(8,4,8), new THREE.MeshStandardMaterial({ color:'#3c414b' }));
  crown.position.y = 2 + 28 + 6 + 4/2 - 1.5; crown.castShadow = crown.receiveShadow = true; building.add(crown);
  const helipad = new THREE.Mesh(new THREE.CylinderGeometry(3.5,3.5,0.12,48), new THREE.MeshStandardMaterial({ color:'#d6d7d8' }));
  helipad.position.y = 2 + 28 + 6 + 4 - 1.5; helipad.receiveShadow = true; building.add(helipad);
  const hbar1 = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.06,0.2), new THREE.MeshStandardMaterial({ color:'#4b4b4b' }));
  hbar1.position.y = helipad.position.y - 0.06; building.add(hbar1);
  const hbar2 = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.06,1.8), new THREE.MeshStandardMaterial({ color:'#4b4b4b' }));
  hbar2.position.y = helipad.position.y - 0.06; building.add(hbar2);
  const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,2.5,8), new THREE.MeshStandardMaterial({ color:'#888' }));
  mast.position.y = 2 + 28 + 6 + 4 + 0.5 - 1.5; building.add(mast);
  for(let i=0;i<12;i++){ const d=new THREE.Mesh(new THREE.BoxGeometry(Math.random()*0.3+0.05,0.05,Math.random()*0.3+0.05), new THREE.MeshStandardMaterial({ color:'#7a7a7a', roughness:0.9 })); d.position.set((Math.random()-0.5)*5, crown.position.y-0.3, (Math.random()-0.5)*5); building.add(d); }
  const ventCol = new THREE.Group(); ventCol.position.set(5.9, 2+10, 0);
  ventCol.add(new THREE.Mesh(new THREE.BoxGeometry(0.1,2,2), new THREE.MeshStandardMaterial({ color:'#565d69' })));
  for(let i=0;i<4;i++){ const duct=new THREE.Mesh(new THREE.BoxGeometry(0.6,0.08,1.6), new THREE.MeshStandardMaterial({ color:'#737c88', metalness:0.4, roughness:0.6 })); duct.position.set(-0.4, -0.7 + i*0.45, 0); ventCol.add(duct); }
  const ventLight = new THREE.PointLight(0xffc080,0.8,2); ventLight.position.set(-0.5,0.2,0); ventCol.add(ventLight); building.add(ventCol);
  const vault = new THREE.Group(); vault.position.set(-5.9, 2+6, 0);
  vault.add(new THREE.Mesh(new THREE.BoxGeometry(0.1,2,2), new THREE.MeshStandardMaterial({ color:'#2a2e35' })));
  const vaultBody = new THREE.Mesh(new THREE.BoxGeometry(1.2,1.6,1.6), new THREE.MeshStandardMaterial({ color:'#1b1f27' })); vaultBody.position.x=0.7; vault.add(vaultBody);
  const vaultPanel = new THREE.Mesh(new THREE.BoxGeometry(1,0.1,1.4), new THREE.MeshStandardMaterial({ color:'#d7c48a' })); vaultPanel.position.set(0.7,-0.2,0); vault.add(vaultPanel); building.add(vault);
  const sign = new THREE.Group(); sign.position.set(0, 2+6, -6.1);
  sign.add(new THREE.Mesh(new THREE.BoxGeometry(1.8,1.1,0.06), new THREE.MeshStandardMaterial({ color:'#a10d0d' })));
  const stripe1 = new THREE.Mesh(new THREE.BoxGeometry(1.6,0.18,0.02), new THREE.MeshStandardMaterial({ color:'#ffffff' })); stripe1.position.z=-0.035; sign.add(stripe1);
  const stripe2 = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.18,0.02), new THREE.MeshStandardMaterial({ color:'#ffffff' })); stripe2.position.set(0,-0.22,-0.035); sign.add(stripe2); building.add(sign);

  const nightGroup = new THREE.Group();
  for(let i=0;i<60;i++){ const pl = new THREE.PointLight(0xffffff,0.25,6); pl.position.set((Math.random()-0.5)*10,2+Math.random()*32,(Math.random()-0.5)*10); nightGroup.add(pl); }
  scene.add(nightGroup);

  const toggle = document.getElementById('toggle');
  function applyMode(){ const night=toggle.checked; ambient.intensity=night?0.35:0.5; dir.intensity=night?1.25:1.35; dir.position.set(night?-20:20,30,15); scene.background = night?nightColor:dayColor; scene.fog.color.set(scene.background); nightGroup.visible = night; }
  toggle.addEventListener('change', applyMode); applyMode();

  window.addEventListener('resize', ()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

  (function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene,camera); })();
})();
</script>
</body>
</html>
